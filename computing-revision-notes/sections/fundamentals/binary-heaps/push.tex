\subsection{Push and Sift-Up}

\begin{OpSectionSummary}
    \OpSig{Push}{item}{}
    \OpSigSep{}
    \OpSig{Sift-Up}{node}{}
\end{OpSectionSummary}

The \emph{push} operation inserts a new item into the heap. The algorithm:
\begin{enumerate}
    \item Add the new item to the next free space while still forming a complete binary tree.
    \item Run \emph{sift-up} starting from the new node to restore the heap property.
\end{enumerate}

The \emph{sift-up} operation moves a node up the tree until it is in the correct position. The algorithm:
\begin{enumerate}
    \item Compare the current node with its parent. If they are in the correct order, then we are done.
    \item Otherwise, swap them, move to the new position of our node, and repeat \emph{sift-up}.
\end{enumerate}

Both algorithms have $O \parens*{\log{n}}$ runtime.

Sample implementation:
\vbox{%
\begin{multicols}{2}
    \begin{lstlisting}[language={Python}, caption={
        Sample Python implementation for \emph{push} and \emph{sift-up} operations on a max-heap, implemented using a list.
    }, label={lst:fundamentals--binary-heaps--push}]
    def hpush(heap, item):
        heap.append(item)
        sift_up(heap, len(heap) - 1)

    def sift_up(heap, i):
        parent = (i - 1) >> 1
        if (i == 0) or (heap[parent] > heap[i]):
            return
        (heap[parent], heap[i]) = (heap[i], heap[parent])
        sift_up(heap, parent)
    \end{lstlisting}
    \columnbreak
    \begin{lstlisting}[language={Python}, caption={
        Sample driver code for \cref{lst:fundamentals--binary-heaps--push}.
        \linebreak
    }]
    # Start with a valid heap
    heap = [94, 87, 81, 57, 68, 74, 5, 35, 36, 29, 41, 18]

    # We push 92 to the heap
    hpush(heap, 92)
    print(heap) # [94, 87, 92, 57, 68, 81, 5,
                #  35, 36, 29, 41, 18, 74]
    \end{lstlisting}
\end{multicols}%
}

\Todo{Provide a visual explainer of what's happening?}

