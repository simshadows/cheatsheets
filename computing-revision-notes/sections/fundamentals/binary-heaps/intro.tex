\section{Binary Heaps}%
\label{sec:fundamentals--binary-heaps}

\subsection{Introduction}

A \emph{heap} is a tree data structure where a \emph{heap property} is fulfilled:
\begin{itemize}
    \item For a \emph{max-heap}, every node's value is greater than or equal to each of their immediate children.
    \item For a \emph{min-heap}, every node's value is lesser than or equal to their immediate children.
\end{itemize}

A \emph{binary heap} is a heap with the form of a binary tree that also fulfills the \emph{shape property}, requiring the tree to also form a \emph{complete binary tree}, meaning:
\begin{enumerate}
    \item all levels except the last are completely filled, and
    \item the last level is filled from left to right.
\end{enumerate}

Heaps are commonly used to implement the \myul{\emph{priority queue}} ADT.

Binary heaps are commonly efficiently implemented using an array (see \cref{fig:fundamentals--binary-heaps--first-example--array}). Notably, each row appears in the array in order from left to right. Since the binary heap is a complete binary tree, the array is a compact representation with no missing nodes before the last node.

\begin{figure}[H]
    \centering
    \subfigure[%
        The conceptual tree structure of the heap.
    ]{%
        \begin{tikzpicture}[
            every node/.style={GraphNodeYellow},
            level 1/.style = {
                sibling distance=48mm,level distance=11mm, nodes={GraphNodeBlue}
            },
            level 2/.style = {
                sibling distance=24mm, level distance=12mm, nodes={GraphNodeRed}
            },
            level 3/.style = {
                sibling distance=12mm, level distance=14mm, nodes={GraphNodeGreen}
            },
            line width=1.6pt,
            -%{Stealth[length=2.4mm, width=2.8mm]}
        ]
            % Started with array:
            %     18 35 74 36 29 81 5 57 87 68 41 94
            % Then we ran a heapify function on it.
            \node(NODE0){94}
                child{node(NODE1){87}
                    child{node(NODE3){57}
                        child{node(NODE7){35}}
                        child{node(NODE8){36}}
                    }
                    child{node(NODE4){68}
                        child{node(NODE9){29}}
                        child{node(NODE10){41}}
                    }
                }
                child{node(NODE2){81}
                    child{node(NODE5){74}
                        child{node(NODE11){18}}
                        child[missing]{}
                    }
                    child{node(NODE6){5}
                        %child[missing]{}
                        %child[missing]{}
                    }
                }
            ;
            \path
                (NODE0.north)  node[fill=none, draw=none, yshift=2.2mm]{$ 0$}
                (NODE1.north)  node[fill=none, draw=none, yshift=2.2mm]{$ 1$}
                (NODE2.north)  node[fill=none, draw=none, yshift=2.2mm]{$ 2$}
                (NODE3.north)  node[fill=none, draw=none, yshift=2.2mm]{$ 3$}
                (NODE4.north)  node[fill=none, draw=none, yshift=2.2mm]{$ 4$}
                (NODE5.north)  node[fill=none, draw=none, yshift=2.2mm]{$ 5$}
                (NODE6.north)  node[fill=none, draw=none, yshift=2.2mm]{$ 6$}
                (NODE7.north)  node[fill=none, draw=none, yshift=2.6mm]{$ 7$}
                (NODE8.north)  node[fill=none, draw=none, yshift=2.6mm]{$ 8$}
                (NODE9.north)  node[fill=none, draw=none, yshift=2.6mm]{$ 9$}
                (NODE10.north) node[fill=none, draw=none, yshift=2.6mm]{$10$}
                (NODE11.north) node[fill=none, draw=none, yshift=2.6mm]{$11$}
            ;
        \end{tikzpicture}
        \label{fig:fundamentals--binary-heaps--first-example--conceptual}
    }
    \quad
    \subfigure[%
        Implementation using the array representation.
    ]{%
        \begin{tikzpicture}[
            array/.style={
                matrix of nodes,
                nodes={draw, minimum size=7mm, fill=DiagramGreenFill},
                column sep=-\pgflinewidth,
                row sep=0.5mm,
                nodes in empty cells,
                row 1/.style={
                    nodes={draw=none, fill=none, minimum size=5mm}
                },
                row 2 column 1/.style={nodes={fill=DiagramYellowFill}},
                row 2 column 2/.style={nodes={fill=DiagramBlueFill}},
                row 2 column 3/.style={nodes={fill=DiagramBlueFill}},
                row 2 column 4/.style={nodes={fill=DiagramRedFill}},
                row 2 column 5/.style={nodes={fill=DiagramRedFill}},
                row 2 column 6/.style={nodes={fill=DiagramRedFill}},
                row 2 column 7/.style={nodes={fill=DiagramRedFill}}
            }
        ]
            % Ugh, I keep getting errors if I use '&', so I'm forced to use
            % '\pgfmatrixnextcell' instead.
            \matrix[array] (array) {
                $0$
                    \pgfmatrixnextcell $1$
                    \pgfmatrixnextcell $2$
                    \pgfmatrixnextcell $3$
                    \pgfmatrixnextcell $4$
                    \pgfmatrixnextcell $5$
                    \pgfmatrixnextcell $6$
                    \pgfmatrixnextcell $7$
                    \pgfmatrixnextcell $8$
                    \pgfmatrixnextcell $9$
                    \pgfmatrixnextcell $10$
                    \pgfmatrixnextcell $11$ \\
                $94$
                    \pgfmatrixnextcell $87$
                    \pgfmatrixnextcell $81$
                    \pgfmatrixnextcell $57$
                    \pgfmatrixnextcell $68$
                    \pgfmatrixnextcell $74$
                    \pgfmatrixnextcell $5$
                    \pgfmatrixnextcell $35$
                    \pgfmatrixnextcell $36$
                    \pgfmatrixnextcell $29$
                    \pgfmatrixnextcell $41$
                    \pgfmatrixnextcell $18$ \\
            };
            \path (0,0) -- (0,-0.9);
        \end{tikzpicture}
        \label{fig:fundamentals--binary-heaps--first-example--array}
    }
    \caption{Example of a \emph{binary max-heap} data structure. (Colours are used only to help show structure.)}%
    \label{fig:fundamentals--binary-heaps--first-example}
\end{figure}

\begin{table}[H]
    \centering
    \caption{Some of the most common operations of a binary heap.}
    \label{tab:fundamentals--binary-heaps--ops}
    \begin{tabular}{|l|l|L{0.6\linewidth}|}
        \hline
        \rowcolor{tableheader}
        \TableHeaderStyle{Operation}
            & \multicolumn{1}{l|}{\TableHeaderStyle{Runtime}}
            & \TableHeaderStyle{Basic Summary}
            \\ \hline\hline
        \OpSig{Push}{item}{}
            & $O \parens*{\log{n}}$
            & Add a single item.
            \\ \hline
        \OpSig{Pop}{}{item}
            & $O \parens*{\log{n}}$
            & Extract and remove the root of the heap (i.e. the \myul{biggest item} of a max-heap, or the \myul{smallest item} of a min-heap).
            \\ \hline
        \OpSig{Push-Pop}{item}{item}
            & $O \parens*{\log{n}}$
            & Equivalent to a push and then a pop, in that order. \emph{Typically more efficient than using the individual operations.}
            \\ \hline
        \OpSig{Pop-Push}{item}{item}
            & $O \parens*{\log{n}}$
            & Equivalent to a pop and then a push, in that order. \emph{Typically more efficient than using the individual operations.}
            \\ \hline
        \OpSig{Heapify}{}{}
            & $O \parens*{n}$
            & Convert an arbitrary \emph{complete binary tree} into a valid heap.
            \\ \hline
        \OpSig{Get Size}{}{size}
            & $O \parens*{1}$
            & Get the number of items in the heap.
            \\ \hline
        \OpSig[internal]{Sift-Up}{node}{}
            & $O \parens*{\log{n}}$
            & Moves a node up the tree until it is in a valid position.
            \\ \hline
        \OpSig[internal]{Sift-Down}{node}{}
            & $O \parens*{\log{n}}$
            & Moves a node down the tree until it is in a valid position.
            \\ \hline
    \end{tabular}
\end{table}

\Todo{List out some more operations?}

