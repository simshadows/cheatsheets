\subsection{Pop and Sift-Down}

\begin{OpSectionSummary}
    \OpSig{Pop}{}{item}
    \OpSigSep{}
    \OpSig{Sift-Down}{node}{}
\end{OpSectionSummary}

The \emph{pop} operation extracts and removes the root of the heap. For a max-heap, the extracted value is the largest item, or for a min-heap, the extracted value is the smallest item. The algorithm:
\begin{enumerate}
    \item Store the current root item. This will be returned later.
    \item Move the bottom-leftmost item into the original place of root.
    \item Run \emph{sift-down} starting from the new root to restore the heap property.
\end{enumerate}

The \emph{sift-down} operation moves a node down the tree until it is in the correct position. The algorithm:
\begin{enumerate}
    \item If our current node is in the correct order with its children, then we are done.
    \item Otherwise, swap the current node and one of the children it's out-of-order with. For a max-heap, we must swap with the larger child, and for a min-heap, we must swap with the smaller child, otherwise these nodes will still be out of order.
    \item Move to our node's new location, and repeat \emph{sift-down}.
    %\item At our current node, select the child with the largest value (if \emph{max-heap}), or the child with the smallest value (if \emph{min-heap}).
    %\item If our current node and this child node are in the correct order, then we are done.
    %\item Otherwise, ...
\end{enumerate}

Both algorithms have $O \parens*{\log{n}}$ runtime.

Sample implementation:
\vbox{%
\begin{multicols}{2}
    \begin{lstlisting}[language={Python}, caption={
        Sample Python implementation for \emph{pop} and \emph{sift-down} operations on a max-heap, implemented using a list.
    }, label={lst:fundamentals--binary-heaps--pop}]
    # PRECONDITION: len(heap) > 0
    def hpop(heap):
        to_return = heap[0]
        heap[0] = heap.pop()
        sift_down(heap, 0)
        return to_return

    def sift_down(heap, i):
        left = (i << 1) + 1
        if left >= len(heap):
            return
        right = left + 1

        if (right >= len(heap)) \
                or (heap[left] > heap[right]):
            next_child = left
        else:
            next_child = right

        if heap[next_child] <= heap[i]:
            return
        (heap[next_child], heap[i]) = \
                (heap[i], heap[next_child])
        sift_down(heap, next_child)
    \end{lstlisting}
    \columnbreak
    \begin{lstlisting}[language={Python}, caption={
        Sample driver code for \cref{lst:fundamentals--binary-heaps--pop}.
        \linebreak
    }]
    # Start with a valid heap
    heap = [94, 87, 81, 57, 68, 74, 5, 35, 36, 29, 41, 18]

    result = hpop(heap)
    print(result) # 94
    print(heap) # [87, 68, 81, 57, 41, 74,
                #  5, 35, 36, 29, 18]
    \end{lstlisting}
\end{multicols}%
}

