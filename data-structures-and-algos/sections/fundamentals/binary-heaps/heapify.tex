\subsubsection{Heapify}

\begin{OpSectionSummary}
    \OpSig{Heapify}{}{}
\end{OpSectionSummary}


The \emph{heapify} operation converts an arbitrary \emph{complete binary tree} into a valid heap. The algorithm simply runs \emph{sift-down} on array nodes $\brackets*{\floor*{n / 2}, \dots, 1, 0}$, in that order.

This algorithm runs in $O \parens*{n}$.

Sample implementation:
\vbox{%
\begin{multicols}{2}
    \begin{lstlisting}[language={Python}, caption={
        Sample Python implementation for \emph{heapify} for max-heaps, using list-based complete binary trees.
    }, label={lst:fundamentals--binary-heaps--heapify}]
    def heapify(heap):
        for i in range(len(heap) >> 1, 0, -1):
            sift_down(heap, i - 1)
    \end{lstlisting}
    \columnbreak
    \begin{lstlisting}[language={Python}, caption={
        Sample driver code for \cref{lst:fundamentals--binary-heaps--heapify}.
        \linebreak
    }]
    # Start with an arbitrary complete binary tree
    heap = [18, 35, 74, 36, 29, 81, 5, 57, 87, 68, 41, 94]

    heapify(heap)
    print(heap) # [94, 87, 81, 57, 68, 74,
                #  5, 35, 36, 29, 41, 18]
    \end{lstlisting}
\end{multicols}%
}

\Todo{Provide a visual explainer of what's happening?}

\Todo{Explain the naive algorithm of repeated push operations, and another alternative algorithm that uses sift-up. Explain why sift-down is the best algorithm.}

