\section{Fibonacci Sequence}%
\label{sec:fibonacci-sequence}


\subsection{Introduction}%

The \emph{Fibonacci sequence} is a sequence in which each number is the sum of the two preceding ones. The sequence commonly begins with $0$ and $1$, so the sequence is written as:
\begin{equation*}
    0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, \dots
\end{equation*}

Mathematically, the Fibonacci sequence is commonly defined by the following recurrence relation:
\begin{equation*}
    F_0 = 0
    \qquad
    F_1 = 1
    \qquad\qquad
    F_n = F_{n - 1} + F_{n - 2}
    \quad \text{for } n > 1
\end{equation*}

For our purposes, we are interested in computing a single term of the sequence.


\subsection{Naive Recursive Algorithm}

A very simple algorithm is to simply implement our definition as a recursive function, though the runtime performance is a nasty $O \parens*{2^n}$. Calculating $F_{42}$ took $45$ seconds with a AMD Ryzen 7 5800HS CPU:
\begin{lstlisting}[language={python}, caption={Python code for a naive recursion algorithm. Time: $O \parens*{2^n}$.}]
def fib(n):
    if n <= 1: return n
    return fib(n - 1) + fib(n - 2)

print(fib(12)) # 144

from timeit import timeit
timeit(lambda : fib(42), number=1) # approx. 45 seconds
\end{lstlisting}


\subsection{Top-Down Memoization Algorithm}

One way to speed it up is the recognition that once we've computed a term of the sequence, we can store it for future use. This algorithm runs in $O(n)$ time since we calculate each term only once:
\begin{lstlisting}[language={python}, caption={Python code for a memoized recursion algorithm.}]
def fib(n):
    memo = {0: 0, 1: 1}
    def _fib(n):
        if n not in memo: memo[n] = _fib(n - 1) + _fib(n - 2)
        return memo[n]
    return _fib(n)

print(fib(12)) # 144

from timeit import timeit
timeit(lambda : fib(42), number=1) # approx. 1.8e-05 seconds (18 microseconds)
timeit(lambda : fib(994), number=1) # approx. 0.00040 seconds (400 microseconds)
timeit(lambda : fib(995), number=1) # Python 3.10.9 'maximum recursion depth exceeded' error
\end{lstlisting}

\emph{Interestingly, if we calculate for $n = 995$ or higher, Python throws a \texttt{maximum recursion depth exceeded} error.}


\subsection{Bottom-Up Algorithm}

You may have already spotted that rather than start from $F_n$ and recursively figuring out what we need to solve it, we could instead start from $F_2$ (and hardcode the base cases $F_0$ and $F_1$) and work our way upwards. This algorithm also runs in $O(n)$:
\begin{lstlisting}[language={python}, caption={Python code for a bottom-up algorithm.}]
def fib(n):
    if n <= 1: return n
    a, b = 0, 1
    for _ in range(1, n):
        a, b = b, a + b
    return b

print(fib(12)) # 144

from timeit import timeit
timeit(lambda : fib(42), number=1) # approx. 4.7e-06 seconds (4.7 microseconds)
timeit(lambda : fib(994), number=1) # approx. 3.9e-05 seconds (39 microseconds)
timeit(lambda : fib(1000000), number=1) # approx. 5.6 seconds
\end{lstlisting}

Usefully, we also 


\subsection{References}
\begin{itemize}
    \item \href{https://en.wikipedia.org/wiki/Fibonacci_sequence}{\textbu{Wikipedia}}: The mathematical notation was taken from here. Also, I stole a bit of the wording from it for the introduction.
\end{itemize}

